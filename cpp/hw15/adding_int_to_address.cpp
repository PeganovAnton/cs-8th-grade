#include <iostream>


using namespace std;


int main()
{
  int a = 0, arr[5] = {10, 20, 30, 40, 50}, *p = 0;
  // Берем 4 байта, расположенные после переменной `a` и интерпретируем их, как
  // переменную типа `int`. Это опасная операция, так как неизвестно, что 
  // находиться после переменной `a`. Кроме того, так можно выйти за границы 
  // области памяти, выделенной ОС под данную программу.
  cout << *(&a + 1) << endl;

  // Операция `(&a)[2]` эквивалентна `*(&a + 2)`.Она также опасна, как и 
  // `*(&a + 1)`.
  cout << (&a)[2] << endl;

  // Отступаем от начала массива налево на 1 и 2 позиции. 
  // Не стоит так делать.
  cout << arr[-1] << ' ' <<  *(arr - 2) <<  endl;

  p = new int;
  // Записываем что-то в 4 байта, следующие за местом, на которое 
  // указывает `p`. Так не стоит делать ни в коем случае.
  *(p + 1) = -4;
  cout << p[1] << endl;

  // Прибавление целого числа `i` к указателю `p` даст указатель на `p[i]`. 
  // Другими словами, изменение указателя зависит от типа переменной.
  // Тип `char` занимает в памяти 1 байт, а тип `int` -- 4 байта. Операция
  // `(char*)p` меняет тип переменной `p` с `int*` на `char*`. Разность равна
  // 4, так как в 4 байтах, занимаемых одним целым числом умещаются 4 
  // переменные типа `char`.
  cout << (char*)(p+1) - (char*)p << endl;

  // Пытаемся получать данные, находящиеся на расстоянии в 4 млн байт от 
  // указателя `p`. Получаем Segmentation fault, так как произошел выход за 
  // границы области памяти выделенной под процесс.
  cout << *(p + 1000000);
}
